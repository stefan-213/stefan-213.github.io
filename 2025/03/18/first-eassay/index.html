<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端js八股 | stefan的小屋</title><meta name="author" content="stefan"><meta name="copyright" content="stefan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="js数据类型有哪些JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中新增的数据类型：  Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。 BigInt 是一种数字类型的数据，它可以表示任意">
<meta property="og:type" content="article">
<meta property="og:title" content="前端js八股">
<meta property="og:url" content="http://example.com/2025/03/18/first-eassay/index.html">
<meta property="og:site_name" content="stefan的小屋">
<meta property="og:description" content="js数据类型有哪些JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中新增的数据类型：  Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。 BigInt 是一种数字类型的数据，它可以表示任意">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg">
<meta property="article:published_time" content="2025-03-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-18T07:59:02.653Z">
<meta property="article:author" content="stefan">
<meta property="article:tag" content="Hexo">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "前端js八股",
  "url": "http://example.com/2025/03/18/first-eassay/",
  "image": "https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg",
  "datePublished": "2025-03-17T16:00:00.000Z",
  "dateModified": "2025-03-18T07:59:02.653Z",
  "author": [
    {
      "@type": "Person",
      "name": "stefan",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/2025/03/18/first-eassay/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端js八股',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style>:root {--card-bg:rgba(255, 255, 255, 0.8) !important;} [data-theme="dark"] {--card-bg:rgba(25, 25, 25, 0.8) !important;}</style><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(./img/背景.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://img0.baidu.com/it/u=325432783,3781093567&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=380&amp;h=377" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://img0.baidu.com/it/u=325432783,3781093567&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=380&amp;h=377" alt="Logo"><span class="site-name">stefan的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">前端js八股</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端js八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T07:59:02.653Z" title="更新于 2025-03-18 15:59:02">2025-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E4%BA%AB/">分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="js数据类型有哪些"><a href="#js数据类型有哪些" class="headerlink" title="js数据类型有哪些"></a>js数据类型有哪些</h1><p><code>JavaScript</code>共有八种数据类型，分别是 <strong>Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt</strong>。</p>
<p>其中 <strong>Symbol</strong> 和 <strong>BigInt</strong> 是ES6 中新增的数据类型：</p>
<ul>
<li><strong>Symbol</strong>代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li><strong>BigInt</strong> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为<strong>原始数据类型</strong>和<strong>引用数据类型（复杂数据类型）</strong>，他们在内存中的存储方式不同。</p>
<ul>
<li><strong>堆：</strong> 存放<strong>引用数据类型</strong>，引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；<strong>引用数据类型在栈中存储了指针</strong>，该指针指向堆中该实体的起始地址，如<code>Object</code>、<code>Array</code>、<code>Function</code>。</li>
<li><strong>栈：</strong> 存放<strong>原始数据类型</strong>，栈中的简单数据段，占据空间小，属于被频繁使用的数据，如<code>String</code>、<code>Number</code>、<code>Null</code>、<code>Boolean</code>。</li>
</ul>
<h1 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h1><p><code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null</code>。</p>
<ul>
<li><strong>undefined</strong> 代表的含义是<strong>未定义</strong>，一般变量<strong>声明了但还没有定义</strong>的时候会返回 <code>undefined</code>，<code>typeof</code>为<code>undefined</code></li>
<li><strong>null</strong> 代表的含义是<strong>空对象</strong>，null主要用于赋值给一些可能会返回对象的变量，作为初始化，<code>typeof</code>为<code>object</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h1 id="instanceof-运算符的实现原理及实现"><a href="#instanceof-运算符的实现原理及实现" class="headerlink" title="instanceof 运算符的实现原理及实现"></a>instanceof 运算符的实现原理及实现</h1><p><code>instanceof</code>运算符适用于检测构造函数的<code>prototype</code>属性上是否出现在某个实例对象的原型链上</p>
<p><code>instanceof</code> 运算符的原理是基于原型链的查找。当使用 <code>obj instanceof Constructor</code> 进行判断时，<code>JavaScript</code> 引擎会从 <code>obj</code> 的原型链上查找 <code>Constructor.prototype</code> 是否存在，如果存在则返回 <code>true</code>，否则继续在原型链上查找。如果查找到原型链的顶端仍然没有找到，则返回 <code>false</code>。</p>
<p><code>instanceof</code>运算符只能用于检查某个对象是否是某个构造函数的实例，不能用于基本类型的检查，如<code>string</code>、<code>number</code>等</p>
<p>「<a target="_blank" rel="noopener" href="https://juejin.cn/spost/7272737742307065914#heading-3">手写代码- 实现一个intanceof操作符</a>」</p>
<h1 id="typeof-和-instanceof-区别"><a href="#typeof-和-instanceof-区别" class="headerlink" title="typeof 和 instanceof 区别"></a>typeof 和 instanceof 区别</h1><p><code>typeof</code>与<code>instanceof</code> 都是判断数据类型的方法，区别如下：</p>
<ul>
<li><code>typeof</code>会返回一个<strong>运算数的基本类型</strong>，<code>instanceof </code>返回的是<strong>布尔值</strong></li>
<li><code>instanceof</code> 可以准确判断<strong>引用数据类型</strong>，但是不能正确判断<strong>原始数据类型</strong></li>
<li><code>typeof</code>虽然可以判断原始数据类型（<code>null</code> 除外），但是无法判断引用数据类型（<code>function</code> 除外）</li>
</ul>
<h2 id="那为什么typeof判断null为object？"><a href="#那为什么typeof判断null为object？" class="headerlink" title="那为什么typeof判断null为object？"></a>那为什么typeof判断null为object？</h2><p>这是 <code>JavaScript</code> 语言的一个历史遗留问题，在第一版<code>JS</code>代码中用32位比特来存储值，通过值的<code>1-3</code>位来识别类型，前三位为<code>000</code>表示对象类型。而<code>null</code>是一个空值，二进制表示都为0，所以前三位也就是<code>000</code>，所以导致 <code>typeof null </code>返回 <code>&quot;object&quot;</code></p>
<h1 id="为什么0-1-0-2-0-3，如何让其相等"><a href="#为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h1><p>因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。 因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><p>将其先转换成整数，再相加之后转回小数。具体做法为先乘10相加后除以10</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=(<span class="number">0.1</span>*<span class="number">10</span>+<span class="number">0.2</span>*<span class="number">10</span>)/<span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x===<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用number对象的toFixed方法，只保留一位小数点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="判断数组的方式有哪些"><a href="#判断数组的方式有哪些" class="headerlink" title="判断数组的方式有哪些"></a>判断数组的方式有哪些</h1><ul>
<li><p>通过Object.prototype.toString.call()做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过原型链做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ES6的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray()</span><br></pre></td></tr></table></figure>

<p>做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过instanceof做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="对类数组对象的理解，如何转化为数组"><a href="#对类数组对象的理解，如何转化为数组" class="headerlink" title="对类数组对象的理解，如何转化为数组"></a>对类数组对象的理解，如何转化为数组</h1><p>类数组也叫<strong>伪数组</strong>，类数组和数组类似，但<strong>不能调用数组方法</strong>，常见的类数组有<strong>arguments</strong>、通过<code>document.getElements</code>获取到的内容等，这些类数组具有<code>length</code>属性。</p>
<p><strong>转换方法</strong></p>
<ul>
<li><p>通过 <code>call</code> 调用数组的 <code>slice</code> 方法来实现转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>call</code> 调用数组的 <code>splice</code> 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>apply</code> 调用数组的 <code>concat</code> 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>Array.from</code> 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Array.propotype.slice.call()是什么</strong> 比如<code>Array.prototype.slice.call(arguments)</code>这句里，就是把 <code>arguments</code> 当做当前对象。</p>
<p>也就是说 要调用的是 <code>arguments</code> 的 <code>slice</code> 方法，而<code>typeof arguments=&quot;Object&quot;</code> 而不是 <code>Array</code></p>
<p>它没有<code>slice</code>这个方法，通过这么<code>Array.prototype.slice.call</code>调用，JS的内部机制应该是 把<code>arguments</code>对象转化为<code>Array</code></p>
<h1 id="数组有哪些原生方法？"><a href="#数组有哪些原生方法？" class="headerlink" title="数组有哪些原生方法？"></a>数组有哪些原生方法？</h1><ul>
<li>数组和字符串的转换方法：<code>toString()</code>、<code>toLocalString()</code>、<code>join() </code>其中<code> join()</code> 方法可以指定转换为字符串时的分隔符。</li>
<li>数组尾部操作的方法 <code>pop()</code> 和<code> push()</code>，<code>push</code> 方法可以传入多个参数。</li>
<li>数组首部操作的方法 <code>shift()</code> 和 <code>unshift()</code> 重排序的方法 <code>reverse()</code> 和<code> sort()</code>，<code>sort()</code> 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>数组连接的方法<code> concat()</code> ，返回的是拼接好的数组，不影响原数组。</li>
<li>数组截取办法 <code>slice()</code>，用于截取数组中的一部分返回，不影响原数组。</li>
<li>数组插入方法 <code>splice()</code>，影响原数组查找特定项的索引的方法，<code>indexOf()</code> 和 <code>lastIndexOf()</code> 迭代方法 <code>every()</code>、<code>some()</code>、<code>filter()</code>、<code>map()</code> 和<code>forEach()</code>方法</li>
<li>数组归并方法 <code>reduce() </code>和 <code>reduceRight()</code> 方法</li>
<li><strong>改变原数组的方法</strong>：<code>fill()</code>、<code>pop()</code>、<code>push()</code>、<code>shift()</code>、<code>splice()</code>、<code>unshift()</code>、<code>reverse()</code>、<code>sort()</code>；</li>
<li><strong>不改变原数组的方法</strong>：<code>concat()</code>、<code>every()</code>、<code>filter()</code>、<code>find()</code>、<code>findIndex()</code>、<code>forEach()</code>、<code>indexOf()</code>、<code>join()</code>、<code>lastIndexOf()</code>、<code>map()</code>、<code>reduce()</code>、<code>reduceRight()</code>、<code>slice()</code>、<code>some()</code>。</li>
</ul>
<h1 id="substring和substr的区别"><a href="#substring和substr的区别" class="headerlink" title="substring和substr的区别"></a>substring和substr的区别</h1><p>它们都是字符串方法，用于截取字符串的一部分，主要区别在于参数不同</p>
<ul>
<li><code>substring(startIndex, endIndex)</code>： 接收两个参数，一个起始索引和结束索引，来指定字符串范围，如果省略第二个参数，则截取到字符串末尾。</li>
<li><code>substr(startIndex, length)</code>： 接收两个参数，并返回从 <code>startIndex</code> 开始，长度为 <code>length</code> 的子字符串。如果省略第二个参数，则截取到字符串末尾。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// 输出: &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">7</span>, <span class="number">5</span>)); <span class="comment">// 输出: &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h1><p><strong>都是浅拷贝</strong></p>
<ul>
<li><code>Object.assign()</code>方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li>
<li>扩展操作符<code>（…）</code>使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 <code>symbols</code> 属性。</li>
</ul>
<h1 id="new操作符的实现原理"><a href="#new操作符的实现原理" class="headerlink" title="new操作符的实现原理"></a>new操作符的实现原理</h1><p><code>new</code>操作符用来创建一个对象，并将该对象绑定到构造函数的<code>this</code>上。</p>
<p>new操作符的执行过程：</p>
<ol>
<li>创建一个空对象</li>
<li>设置原型，将构造函数的原型指向空对象的 <code>prototype</code> 属性。</li>
<li>将 <code>this</code> 指向这个对象，通过apply执行构造函数。</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</li>
</ol>
<p>「<a target="_blank" rel="noopener" href="https://juejin.cn/spost/7272737742307065914#heading-2">手写代码-实现一个new操作符</a>」</p>
<h1 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h1><p><code>for...in</code>和<code>for...of</code>都是<code>JavaScript</code>中的循环语句，而<code>for…of </code>是ES6新增的遍历方式，允许遍历一个含有<code>iterator</code>接口的数据结构（数组、对象等）并且返回各项的值，和<code>ES3</code>中的<code>for…in</code>的区别如下</p>
<ul>
<li><code>for…of </code>遍历获取的是<strong>对象的键值</strong>，<code>for…in</code> 获取的是<strong>对象的键名</strong>；</li>
<li><code>for… in</code> 会遍历对象的<strong>整个原型链</strong>，性能非常差不推荐使用，而 <code>for … of</code> 只遍历当前对象不会遍历原型链；</li>
<li>对于数组的遍历，<code>for…in</code> 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，<code>for…of</code> 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结</strong>：<code>for...in</code> 循环主要是为了遍历对象而生，不适用于遍历数组；<code>for...of</code> 循环可以用来遍历数组、类数组对象，字符串、<code>Set</code>、<code>Map</code> 以及 <code>Generator</code> 对象。</p>
<h1 id="如何使用for…of遍历对象"><a href="#如何使用for…of遍历对象" class="headerlink" title="如何使用for…of遍历对象"></a>如何使用for…of遍历对象</h1><p><strong>为什么不能遍历对象</strong></p>
<p><code>for…of</code>是作为ES6新增的遍历方式，能被其遍历的数据内部都有一个<strong>遍历器iterator接口</strong>，而数组、字符串、<code>Map</code>、<code>Set</code>内部已经实现，普通对象内部没有，所以在遍历的时候会报错。想要遍历对象，可以给对象添加一个<code>Symbol.iterator</code>属性，并指向一个迭代器即可</p>
<p>在迭代器里面，通过<code>Object.keys</code>获取对象所有的<code>key</code>，然后遍历返回<code>key 、value</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js 代码解读复制代码<span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*()&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对AJAX的理解，实现一个AJAX请求"><a href="#对AJAX的理解，实现一个AJAX请求" class="headerlink" title="对AJAX的理解，实现一个AJAX请求"></a>对AJAX的理解，实现一个AJAX请求</h1><p><code>AJAX</code>是 Asynchronous JavaScript and XML 的缩写，<strong>指的是通过 JavaScript 的 异步通信</strong>，从服务器获取 <code>XML</code> 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建<code>AJAX</code>请求的步骤：</p>
<ul>
<li>创建一个 <code>XMLHttpRequest</code> 对象。</li>
<li>在这个对象上使用 <code>open</code> 方法创建一个 <code>HTTP</code> 请求，<code>open</code> 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 <code>setRequestHeader</code> 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 <code>XMLHttpRequest</code> 对象一共有 5 个状态，当它的状态变化时会触发<code>onreadystatechange</code> 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 <code>readyState</code> 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 <code>response</code> 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调用 <code>send</code> 方法来向服务器发起请求，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h1 id="ajax、axios、fetch的区别"><a href="#ajax、axios、fetch的区别" class="headerlink" title="ajax、axios、fetch的区别"></a>ajax、axios、fetch的区别</h1><p><strong>ajax</strong></p>
<ul>
<li>基于原生<code>XHR</code>开发，<code>XHR</code>本身架构不清晰。</li>
<li>针对<strong>MVC</strong>编程，不符合现在前端MVVM的浪潮。</li>
<li>多个请求之间如果有先后关系的话，就会出现回调地狱</li>
<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
<p><strong>axios</strong></p>
<ul>
<li>支持<code>Promise</code>API</li>
<li>从浏览器中创建<code>XMLHttpRequest</code></li>
<li>从 <code>node.js</code> 创建 <code>http</code> 请求</li>
<li>支持请求拦截和响应拦截</li>
<li>自动转换<code>JSON</code>数据</li>
<li>客服端支持防止<code>CSRF/XSRF</code></li>
</ul>
<p><strong>fetch</strong></p>
<ul>
<li>浏览器原生实现的请求方式，ajax的替代品</li>
<li>基于标准 <code>Promise</code> 实现，支持<code>async/await</code></li>
<li><code>fetchtch</code>只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>默认不会带<code>cookie</code>，需要添加配置项</li>
<li><code>fetch</code>没有办法原生监测请求的进度，而<code>XHR</code>可以。</li>
</ul>
<h1 id="forEach和map方法有什么区别"><a href="#forEach和map方法有什么区别" class="headerlink" title="forEach和map方法有什么区别"></a>forEach和map方法有什么区别</h1><p>两个方法都是用来遍历循环数组，区别如下：</p>
<ul>
<li><code>forEach()</code>对数据的操作会改变原数组，该方法没有返回值；</li>
<li><code>map()</code>方法不会改变原数组的值，<strong>返回一个新数组</strong>，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h1 id="什么是尾调用，使用尾调用有什么好处？"><a href="#什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="什么是尾调用，使用尾调用有什么好处？"></a>什么是尾调用，使用尾调用有什么好处？</h1><p>尾调用就是在函数的<strong>最后一步调用函数</strong>，在一个函数里调用另外一个函数会<strong>保留当前执行的上下文</strong>，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，<strong>从而节省内存</strong>。但是ES6的尾调用只能在<strong>严格模式下开启</strong>，正常模式是无效的。</p>
<h1 id="你用过哪些设计模式"><a href="#你用过哪些设计模式" class="headerlink" title="你用过哪些设计模式"></a>你用过哪些设计模式</h1><ul>
<li><strong>单例模式</strong>：保证类只有一个实例，并提供一个访问它的全局访问点。</li>
<li><strong>工厂模式</strong>：用来创建对象，根据不同的参数返回不同的对象实例。</li>
<li><strong>策略模式</strong>：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</li>
<li><strong>装饰器模式</strong>：在不改变对象原型的基础上，对其进行包装扩展。</li>
<li><strong>观察者模式</strong>：定义了对象间一种一对多关系，当目标对象状态发生改变时，所有依赖它对对象都会得到通知。</li>
<li><strong>发布订阅模式</strong>： 基于一个主题&#x2F;事件通道，希望接收通知的对象通过自定义事件订阅主题，被激活事件的对象（通过发布主题事件的方式被通知)。</li>
</ul>
<h1 id="如何实现深浅拷贝"><a href="#如何实现深浅拷贝" class="headerlink" title="如何实现深浅拷贝"></a>如何实现深浅拷贝</h1><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li><pre><code>JSON.stringify()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将js对象序列化，再通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JSON.parse
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  反序列</span><br><span class="line"></span><br><span class="line">  - 如果对象中有函数、`undefined`、`symbol`时，都会丢失</span><br><span class="line">  - 如果有正则表达式、`Error`对象等，会得到空对象</span><br><span class="line"></span><br><span class="line">「[手写代码-手写深拷贝](https://juejin.cn/spost/7272737742307065914#heading-8)」</span><br><span class="line"></span><br><span class="line">### 浅拷贝</span><br><span class="line"></span><br><span class="line">- `Objec.assign()` 拷贝对象</span><br><span class="line">- 扩展运算符</span><br><span class="line"></span><br><span class="line">「[手写代码-手写浅拷贝](https://juejin.cn/spost/7272737742307065914#heading-7)」</span><br><span class="line"></span><br><span class="line"># ES6</span><br><span class="line"></span><br><span class="line">## let、const、var的区别</span><br><span class="line"></span><br><span class="line">- 块级作用域：</span><br><span class="line"></span><br><span class="line">  块作用域由 &#123; &#125;包裹，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</span><br><span class="line"></span><br><span class="line">  - 内层变量可能覆盖外层变量</span><br><span class="line">  - 用来计数的循环变量泄露为全局变量</span><br><span class="line"></span><br><span class="line">- **变量提升：** `var`存在变量提升，`let`和`const`不存在变量提升，即在变量只能在声明之后使用，否在会报错。</span><br><span class="line"></span><br><span class="line">- **给全局添加属性：** 浏览器的全局对象是`window`，`Node`的全局对象是`global`。`var`声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是`let`和`const`不会。</span><br><span class="line"></span><br><span class="line">- **重复声明：** `var`声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。`const`和`let`不允许重复声明变量。</span><br><span class="line"></span><br><span class="line">- **初始值设置：** 在变量声明时，`var `和`let`可以不用设置初始值。而`const`声明变量必须设置初始值。</span><br><span class="line"></span><br><span class="line">- **暂时性死区**：在使用`let`、`const`命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用`var`声明的变量不存在暂时性死区。</span><br><span class="line"></span><br><span class="line">## 箭头函数与普通函数的区别</span><br><span class="line"></span><br><span class="line">- 箭头函数是**匿名函数**，不能作为构造函数，使用`new`关键字。</span><br><span class="line">- 箭头函数没有`arguments`</span><br><span class="line">- 箭头函数没有自己的`this`，会获取所在的上下文作为自己的`this`</span><br><span class="line">- `call()`、`applay()`、`bind()`方法不能改变箭头函数中的`this`指向</span><br><span class="line">- 箭头函数没有`prototype`</span><br><span class="line">- 箭头函数不能用作`Generator`函数，不能使用`yeild`关键字</span><br><span class="line"></span><br><span class="line">## Set、Map的区别</span><br><span class="line"></span><br><span class="line">**Set**</span><br><span class="line"></span><br><span class="line">- 创建：`  new Set([1, 1, 2, 3, 3, 4, 2])`</span><br><span class="line">- `add(value)`：添加某个值，返回Set结构本身。</span><br><span class="line">- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class="line">- `has(value)`：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class="line">- `clear()`：清除所有成员，没有返回值。</span><br><span class="line"></span><br><span class="line">**Map**</span><br><span class="line"></span><br><span class="line">- `set(key, val):` 向`Map`中添加新元素</span><br><span class="line">- `get(key):` 通过键值查找特定的数值并返回</span><br><span class="line">- `has(key): `判断`Map`对象中是否有`Key`所对应的值，有返回`true`,否则返回`false`</span><br><span class="line">- `delete(key): `通过键值从`Map`中移除对应的数据</span><br><span class="line">- `clear():` 将这个`Map`中的所有元素删除</span><br><span class="line"></span><br><span class="line">#### 区别</span><br><span class="line"></span><br><span class="line">- `Map`是一种键值对的集合，和对象不同的是，键可以是任意值</span><br><span class="line">- `Map`可以遍历，可以和各种数据格式转换</span><br><span class="line">- `Set`是类似数组的一种的数据结构，类似数组的一种集合，但在Set中没有重复的值</span><br><span class="line"></span><br><span class="line">## map和Object的区别</span><br><span class="line"></span><br><span class="line">`map`和`Object`都是用键值对来存储数据，区别如下：</span><br><span class="line"></span><br><span class="line">- **键的类型**：`Map` 的键可以是**任意数据类型**（包括对象、函数、`NaN `等），而 `Object` 的键**只能是字符串**或者 `Symbol` 类型。</span><br><span class="line">- **键值对的顺序**：`Map`中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。</span><br><span class="line">- **键值对的遍例**：`Map` 的键值对可以使用 `for...of` 进行遍历，而 `Object` 的键值对需要手动遍历键值对。</span><br><span class="line">- **继承关系**：`Map `没有继承关系，而 `Object` 是所有对象的基类。</span><br><span class="line"></span><br><span class="line">## map和weakMap的区别</span><br><span class="line"></span><br><span class="line">它们是 `JavaScript` 中的两种不同的键值对集合，主要区别如下：</span><br><span class="line"></span><br><span class="line">1. `map`的键可以是任意类型，`weakMap`键只能是对象类型。</span><br><span class="line">2. `map` 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，`map` 仍然会保留该键的内存。`weakMap` 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。</span><br><span class="line"></span><br><span class="line">## 说说你对Promise的理解</span><br><span class="line"></span><br><span class="line">`Promise`是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。</span><br><span class="line"></span><br><span class="line">`Promise`的实例有三个状态:</span><br><span class="line"></span><br><span class="line">- `Pending`（初始状态）</span><br><span class="line">- `Fulfilled`（成功状态）</span><br><span class="line">- `Rejected`（失败状态）</span><br><span class="line"></span><br><span class="line">`Promise`的实例有两个过程：</span><br><span class="line"></span><br><span class="line">- `pending` -&gt; `fulfilled` : **Resolved（已完成）**</span><br><span class="line"></span><br><span class="line">- `pending` -&gt; `rejected`：**Rejected（已拒绝）**</span><br><span class="line"></span><br><span class="line">  注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。</span><br><span class="line"></span><br><span class="line">`Promise`构造函数接收一个带有`resolve`和`reject`参数的回调函数。</span><br><span class="line"></span><br><span class="line">- `resolve`的作用是将`Promise`状态从`pending`变为`fulfilled`，在异步操作成功时调用，并将异步结果返回，作为参数传递出去</span><br><span class="line">- `reject`的作用是将`Promise`状态从`pending`变为`rejected`，在异步操作失败后，将异步操作错误的结果，作为参数传递出去</span><br><span class="line"></span><br><span class="line">`Promise`的缺点：</span><br><span class="line"></span><br><span class="line">- 无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。</span><br><span class="line">- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。</span><br><span class="line">- 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</span><br><span class="line"></span><br><span class="line">## Promise方法</span><br><span class="line"></span><br><span class="line">- `promise.then()`  对应`resolve`成功的处理</span><br><span class="line">- `promise.catch()`对应`reject`失败的处理</span><br><span class="line">- `promise.all()`可以完成并行任务，将多个`Promise`实例数组，包装成一个新的`Promise`实例，返回的实例就是普通的`Promise`。有一个失败，代表该`Primise`失败。当所有的子`Promise`完成，返回值时全部值的数组</span><br><span class="line">- `promise.race()`类似`promise.all()`，区别在于有任意一个完成就算完成</span><br><span class="line">- `promise.allSettled()` 返回一个在所有给定的 `promise` 都已经 `fulfilled` 或 `rejected` 后的 `promise` ，并带有一个对象数组，每个对象表示对应的`promise` 结果。</span><br><span class="line"></span><br><span class="line">## promise.all 和 promise.allsettled 区别</span><br><span class="line"></span><br><span class="line">`Promise.all()` 和 `Promise.allSettled()` 都是用来处理多个 `Promise` 实例的方法，它们的区别在于以下几点：</span><br><span class="line"></span><br><span class="line">- **all:** 只有当所有`Promise`实例都`resolve`后，才会`resolve`返回一个由所有`Promise`返回值组成的数组。如果有一个`Promise`实例`reject`，就会立即被拒绝，并返回拒绝原因。`all`是团队的成功才算，如果有一个人失败就算失败。</span><br><span class="line">- **allSettled：** 等所有`Promise`执行完毕后，不管成功或失败， 都会吧每个`Promise`状态信息放到一个数组里面返回。</span><br><span class="line"></span><br><span class="line">## 对async/await 的理解</span><br><span class="line"></span><br></pre></td></tr></table></figure>
async/await`其实**是Generator 的语法糖**，它能实现的效果都能用`then`链来实现，它是为优化`then`链而开发出来的。通过`async`关键字声明一个异步函数， `await `用于等待一个异步方法执行完成，**并且会阻塞执行**。 `async` 函数**返回的是一个 Promise 对象**，如果在函数中 `return` 一个变量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `Promise` 对象。如果没有返回值，返回 `Promise.resolve(undefined)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## async/await对比Promise的优势</span><br><span class="line"></span><br><span class="line">- 代码可读性高，`Promise`虽然摆脱了回掉地狱，但自身的链式调用会影响可读性。</span><br><span class="line">- 相对`Promise`更优雅，传值更方便。</span><br><span class="line">- 对错误处理友好，可以通过`try/catch`捕获，`Promise`的错误捕获⾮常冗余</span><br><span class="line"></span><br><span class="line">## 谈谈你对ES6的理解</span><br><span class="line"></span><br><span class="line">- 解构赋值</span><br><span class="line">- 扩展运算符</span><br><span class="line">- 箭头函数</span><br><span class="line">- 模版字符串</span><br><span class="line">- `Set`、`Map`集合</span><br><span class="line">- 新增`class`类</span><br><span class="line">- `Proxy`</span><br><span class="line">- `Promise`</span><br><span class="line">- ...</span><br><span class="line"></span><br><span class="line">## ES6模块和CommonJS模块有什么区别</span><br><span class="line"></span><br><span class="line">- 语法不同：</span><br><span class="line"></span><br><span class="line">  ES6 模块使用 import 和 export关键字来导入和导出模块，而 CommonJS 模块使用 require和 module.exports或 exports来导入和导出模块。</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  // ES6 模块</span><br><span class="line">  import &#123; foo &#125; from &#x27;./module&#x27;;</span><br><span class="line">  export const bar = &#x27;bar&#x27;;</span><br><span class="line">  </span><br><span class="line">  // CommonJS 模块</span><br><span class="line">  const foo = require(&#x27;./commonjs&#x27;);</span><br><span class="line">  exports.bar = &#x27;bar&#x27;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>异步加载: <code>ES6</code> 模块支持动态导入（dynamic import），<strong>可以异步加载模块</strong>。这使得在需要时按需加载模块成为可能，从而提高了性能。<code>CommonJS</code> 模块在设计时没有考虑异步加载的需求，通常在模块的顶部进行同步加载。</p>
</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul>
<li><strong>prototype</strong> : js通过构造函数来创建对象，每个构造函数内部都会一个原型<code>prototype</code>属性，它指向另外一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</li>
<li><em><strong>*proto*</strong></em>: 当使用构造函数创建一个实例对象后，可以通过<code>__proto__</code>访问到<code>prototype</code>属性。</li>
<li><strong>constructor</strong>：实例对象通过这个属性可以访问到构造函数</li>
</ul>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>每个实例对象都有一个<code>__proto__</code>属性指向它的构造函数的原型对象，而这个原型对象也会有自己的原型对象，一层一层向上，直到顶级原型对象<code>null</code>，这样就形成了一个原型链。</p>
<p>当访问对象的一个属性或方法时，当对象身上不存在该属性方法时，就会沿着原型链向上查找，直到查找到该属性方法位置。</p>
<p>原型链的顶层原型是<code>Object.prototype</code>，如果这里没有就只指向<code>null</code></p>
<h1 id="实现寄生组合继承"><a href="#实现寄生组合继承" class="headerlink" title="实现寄生组合继承"></a>实现寄生组合继承</h1><p>利用<code>Object.create()</code>方法，将子类的原型指向父类，实现继承父类的方法属性，修改时也不影响父类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="comment">// 执行父类构造函数</span></span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型  指向父类</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 此时的狗早函数为父类的 需要指回自己</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;Tom&#x27;</span></span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h1 id="对闭包的理解已经它的使用场景"><a href="#对闭包的理解已经它的使用场景" class="headerlink" title="对闭包的理解已经它的使用场景"></a>对闭包的理解已经它的使用场景</h1><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p><strong>闭包优点：</strong></p>
<ul>
<li>创建全局私有变量，避免变量全局污染</li>
<li>可以实现封装、缓存等</li>
</ul>
<p><strong>闭包缺点：</strong></p>
<ul>
<li>创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出<ul>
<li><strong>解决：</strong> 在不需要使用的时候把变量设为<code>null</code></li>
</ul>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>用于创建全局私有变量</li>
<li>封装类和模块</li>
<li>实现函数柯里化</li>
</ul>
<h2 id="闭包一定会造成内存泄漏吗？"><a href="#闭包一定会造成内存泄漏吗？" class="headerlink" title="闭包一定会造成内存泄漏吗？"></a>闭包一定会造成内存泄漏吗？</h2><p>闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。</p>
<h1 id="对作用域、作用域链的理解"><a href="#对作用域、作用域链的理解" class="headerlink" title="对作用域、作用域链的理解"></a>对作用域、作用域链的理解</h1><p><strong>作用域</strong>是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期。</p>
<ol>
<li><strong>全局作用域</strong>：可以全局访问<ul>
<li>最外层函数和最外层定义的变量拥有全局作用域</li>
<li><code>window</code>上的对象属性方法拥有全局作用域</li>
<li>为定义直接复制的变量自动申明拥有全局作用域</li>
<li>过多的全局作用域变量会导致变量全局污染，命名冲突</li>
</ul>
</li>
<li><strong>函数作用域</strong>：只能在函数中访问使用哦<ul>
<li>在函数中定义的变量，都只能在内部使用，外部无法访问</li>
<li>内层作用域可以访问外层，外层不能访问内存作用域</li>
</ul>
</li>
<li>ES6中的<strong>块级作用域</strong>：只在代码块中访问使用<ul>
<li>使用ES6中新增的<code>let</code>、<code>const</code>什么的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域）</li>
<li><code>let</code>、<code>const</code>申明的变量不会变量提升，<code>const</code>也不能重复申明</li>
<li>块级作用域主要用来解决由变量提升导致的变量覆盖问题</li>
</ul>
</li>
</ol>
<p><strong>作用域链：</strong> 变量在指定的作用域中没有找到，会依次向一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。</p>
<h1 id="call-、bind（）、-apply-的区别？"><a href="#call-、bind（）、-apply-的区别？" class="headerlink" title="call() 、bind（）、 apply() 的区别？"></a>call() 、bind（）、 apply() 的区别？</h1><ul>
<li>都可以用作改变<code>this</code>指向</li>
<li><code>call</code>和<code>apply</code>的区别在于传参，<code>call</code>、<code>bind</code>都是传入对象。<code>apply</code>传入一个数组。</li>
<li><code>call</code>、<code>apply</code>改变<code>this</code>指向后会立即执行函数，<code>bind</code>在改变<code>this</code>后返回一个函数，不会立即执行函数，需要手动调用。</li>
</ul>
<p>「<a target="_blank" rel="noopener" href="https://juejin.cn/spost/7272737742307065914#heading-9">手写代码-call、bind、apply</a>」</p>
<h3 id="连续多个-bind，最后this指向是什么？"><a href="#连续多个-bind，最后this指向是什么？" class="headerlink" title="连续多个 bind，最后this指向是什么？"></a>连续多个 bind，最后this指向是什么？</h3><p>在 <code>JavaScript</code> 中，连续多次调用 <code>bind</code> 方法，最终函数的 <code>this</code> 上下文是由<strong>第一次调用 bind 方法</strong>的参数决定的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = getName.<span class="title function_">bind</span>(obj1).<span class="title function_">bind</span>(obj2).<span class="title function_">bind</span>(obj3);</span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">// 输出 &quot;obj1&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h1><p><strong>垃圾回收</strong>：<code>JavaScript</code>代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。</p>
<p>在 V8 中，会把堆分为<strong>新生代和老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象：</p>
<ul>
<li><p>Major  GC(主垃圾回收器)</p>
<p>：主要负责老生代垃圾的回收</p>
<ul>
<li>内存占用比较小</li>
</ul>
</li>
<li><p>Minor GC(副垃圾回收器)</p>
<p>：主要负责新生代垃圾的回收</p>
<ul>
<li>对象的占用空间大  对象存活时间长 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b90d49a71ff04b1b926a00e4acc3cb8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=801&h=540&s=47668&e=png&b=fefefe" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="新生代（副垃圾回收器）"><a href="#新生代（副垃圾回收器）" class="headerlink" title="新生代（副垃圾回收器）"></a>新生代（副垃圾回收器）</h3><p>副垃圾回收器主要负责新⽣代的垃圾回收。大多数的对象最开始都会被分配在新生代，该存储空间相对较小，分为两个空间：<strong>from 空间</strong>（对象区）和 <strong>to 空间</strong>（空闲区）。</p>
<ul>
<li>新增变量会放到<code>To</code>空间，当空间满后需要执行一次垃圾清理操作</li>
<li>对垃圾数据进行标记，标记完成后<strong>将存活的数据复制到From空间中</strong>，有序排列</li>
<li>交换两个空间，原来的<code>To</code>变成<code>From</code>，旧的<code>From</code>变成<code>To</code></li>
</ul>
<h3 id="老生代（主垃圾回收器）"><a href="#老生代（主垃圾回收器）" class="headerlink" title="老生代（主垃圾回收器）"></a>老生代（主垃圾回收器）</h3><p>主垃圾回收器主要负责⽼⽣代中的垃圾回收。存储一些占用空间大、存活时间长的数据，采用<strong>标记清除</strong>算法进行垃圾回收。</p>
<p>主要分为<strong>标记</strong>、<strong>清除</strong>两个阶段。</p>
<ul>
<li><strong>标记</strong>：将所有的变量打上标记0，然后从根节点(<code>window</code>对象、DOM树等)开始遍历，把存活的变量标记为1</li>
<li><strong>清除</strong>：清除标记为0的对象，释放内存。清除后将1的变量改为0，方便下一轮回收。</li>
</ul>
<p>对⼀块内存多次执⾏标记清除算法后，会<strong>产⽣⼤量不连续的内存碎⽚</strong>。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——<strong>标记整理</strong>。</p>
<p><strong>标记整理</strong>的标记过程仍然与标记清除算法⾥的是⼀样的，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有<strong>存活的对象都向⼀端移动</strong>，然后直接清理掉这⼀端之外的内存。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>一个对象被引用一次，引用数就+1，反之就-1。当引用为0，就会出发垃圾回收。</p>
<p>这种方式会产生一个问题，在循环引用时，引用数永远不会为0，无法回收。</p>
<h2 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h2><ul>
<li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>被遗忘的计时器或回调函数：设置了 <code>setInterval</code> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>脱离 <code>DOM</code> 的引用：获取一个 <code>DOM</code> 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 手写 instanceof 方法</span></span><br><span class="line"><span class="comment"> * 用法：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、通过 Object.getPrototypeOf 获取 obj 的原型</span></span><br><span class="line"><span class="comment"> *  2、循环判断 objProtoType 是否和 constructor 的原型相等</span></span><br><span class="line"><span class="comment"> *    2.1、如果相等就返回 true</span></span><br><span class="line"><span class="comment"> *    2.2、如果不相等 就重新赋值一下 obj 的原型 进入下一次循环</span></span><br><span class="line"><span class="comment"> *  3、判断是 objProtoType 是否为空 如果为空就说明不存在 返回 false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; obj 需要判断的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj, type</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!objPrototype) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (objPrototype === type.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    objPrototype = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(objPrototype)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写new操作符"><a href="#手写new操作符" class="headerlink" title="手写new操作符"></a>手写new操作符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 手写 new 操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 用法：创建一个实例化对象</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1、判断传入的 fn 是否为 function</span></span><br><span class="line"><span class="comment"> * 2、创建一个空对象</span></span><br><span class="line"><span class="comment"> * 3、将这个空对象的原型设置为构造函数的 prototype 属性。</span></span><br><span class="line"><span class="comment"> * 4、使用 apply 执行构造函数 并传入参数 arguments 获取函数的返回值</span></span><br><span class="line"><span class="comment"> * 5、判断这个返回值 如果返回的是 Object || Function 类型 就返回该对象 否则返回创建的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; fn 构造函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">     <span class="comment">// 判断 fn 是否为函数</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;fn must be a function&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将这个空对象的原型设置为构造函数的 prototype 属性。</span></span><br><span class="line">  obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 apply 执行构造函数 传入参数 获取返回值</span></span><br><span class="line">  <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(obj, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断这个返回值 如果返回的是 Object || Function 类型 就返回该对象 否则返回创建的对象</span></span><br><span class="line">  <span class="keyword">const</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="手写深浅拷贝"><a href="#手写深浅拷贝" class="headerlink" title="手写深浅拷贝"></a>手写深浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 浅拷贝</span></span><br><span class="line"><span class="comment"> * 用法：浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、判断是否为对象</span></span><br><span class="line"><span class="comment"> *  2、根据obj类型创建一个新的对象</span></span><br><span class="line"><span class="comment"> *  3、for in 遍历对象 拿到 key</span></span><br><span class="line"><span class="comment"> *  4、判断 key 是否在 obj 中</span></span><br><span class="line"><span class="comment"> *  5、将 key 作为新对象的key 并赋值 value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新的对象</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环遍历 obj 将 key 作为 newObj 的 key 并赋值value</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否在 obj 中</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 深拷贝</span></span><br><span class="line"><span class="comment"> * 用法：拷贝一个对象的属性值 如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、判断是否为对象</span></span><br><span class="line"><span class="comment"> *  2、判段对象是否在 map 中 如果存在就不需要操作</span></span><br><span class="line"><span class="comment"> *  3、将 obj 放入 map 中 避免重复引用</span></span><br><span class="line"><span class="comment"> *  4、for in 遍历对象 拿到 key 判断 key 是否在 obj 中</span></span><br><span class="line"><span class="comment"> *  5、value 如果为对象 就递归拷贝 否则就赋值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">obj</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; [map=new Map()]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 obj 是否在 map 中存在 如果存在就不需要递归调用 直接返回数据</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放入 map 中 记录当前对象 避免重复拷贝 循环引用</span></span><br><span class="line">  map.<span class="title function_">set</span>(obj, newObj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 如果 value 还是一个对象 递归获取 否则就赋值</span></span><br><span class="line">      newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[key], map) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 手写 call</span></span><br><span class="line"><span class="comment"> * 用法：call 方法用于调用一个函数，并指定函数内部 this 的指向，传入一个对象</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、判断 this 是否指向一个函数  只有函数才可以执行</span></span><br><span class="line"><span class="comment"> *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window</span></span><br><span class="line"><span class="comment"> *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上 然后执行获取 result 传入 ...args 确保参数位置正确</span></span><br><span class="line"><span class="comment"> *  4、删除 context 对象的 fn 属性 并将 result 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 手写 apply</span></span><br><span class="line"><span class="comment"> * 用法：apply 方法用于调用一个函数，并指定函数内部 this 的指向，传入一个数组</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、判断 this 是否指向一个函数  只有函数才可以执行</span></span><br><span class="line"><span class="comment"> *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window</span></span><br><span class="line"><span class="comment"> *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上的一个 fn 属性上</span></span><br><span class="line"><span class="comment"> *  4、执行 fn 函数 判断 args 是否有 如果没有参数就直接执行 如果有参数 将参数展开传入 fn</span></span><br><span class="line"><span class="comment"> *  5、删除 context 对象的 fn 属性 并将 result 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和 call 一样 只不过传入的参数只有一个 类型为数组 在执行 fn 的时候将参数展开</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = args ? context.<span class="title function_">fn</span>(...args) : context.<span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 手写 bind</span></span><br><span class="line"><span class="comment"> * 用法：bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、判断 this 是否指向一个函数  只有函数才可以执行</span></span><br><span class="line"><span class="comment"> *  2、获取传入的 context 上下文 也就是我们要指向的 如果不存在就指向 window</span></span><br><span class="line"><span class="comment"> *  3、将当前 this 也就是外部需要执行的函数 绑定到 context 上的一个 fn 属性上</span></span><br><span class="line"><span class="comment"> *  4、返回一个函数 供外部调用 执行函数后传入新的参数</span></span><br><span class="line"><span class="comment"> *  5、执行在闭包内缓存的 fn 将两次参数一起传入 删除 fn 返回 result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context, ...args1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;type error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和 call apply 不一样的是 bind 返回一个函数 需要在外部执行  参数为多个对象 且返回的对象里也会有参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args1, ...args2)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">stefan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/18/first-eassay/">http://example.com/2025/03/18/first-eassay/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">stefan的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hexo/">Hexo</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post-share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/03/18/file-upload/" title="文件上传（批量+git）"><img class="cover" src="https://img2.baidu.com/it/u=1752158855,1571382153&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=1400" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">文件上传（批量+git）</div></div></div></a><a class="pagination-related  no-desc" href="/2025/03/19/code/" title="算法"><img class="cover" src="https://img0.baidu.com/it/u=873097404,573333836&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=801&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">算法</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/03/19/front-introduction/" title="前端入门"><img class="cover" src="https://img2.baidu.com/it/u=3514067637,2951611904&fm=253&fmt=auto&app=138&f=JPEG?w=875&h=500" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="info-item-2">前端入门</div></div></div></a><a class="pagination-related no-desc" href="/2025/03/19/code/" title="算法"><img class="cover" src="https://img0.baidu.com/it/u=873097404,573333836&fm=253&fmt=auto&app=138&f=JPEG?w=801&h=500" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="info-item-2">算法</div></div></div></a><a class="pagination-related no-desc" href="/2025/03/18/file-upload/" title="文件上传（批量+git）"><img class="cover" src="https://img2.baidu.com/it/u=1752158855,1571382153&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=1400" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">文件上传（批量+git）</div></div></div></a><a class="pagination-related no-desc" href="/2025/03/17/hello-world/" title="Hello World"><img class="cover" src="https://pic4.zhimg.com/v2-0d5dd12da572c59207694beca78e4baf_1440w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">Hello World</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=325432783,3781093567&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=380&amp;h=377" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">stefan</div><div class="author-info-description">一个平平无奇的学生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/stefan-213/stefan-213.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.</span> <span class="toc-text">js数据类型有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">null和undefined区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">instanceof 运算符的实现原理及实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typeof-%E5%92%8C-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">typeof 和 instanceof 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88typeof%E5%88%A4%E6%96%ADnull%E4%B8%BAobject%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">那为什么typeof判断null为object？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89"><span class="toc-number">5.</span> <span class="toc-text">为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.</span> <span class="toc-text">判断数组的方式有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">对类数组对象的理解，如何转化为数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">数组有哪些原生方法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#substring%E5%92%8Csubstr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">substring和substr的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#object-assign%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E6%B3%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">new操作符的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">for…in和for…of的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8for%E2%80%A6of%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">如何使用for…of遍历对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9AJAX%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAJAX%E8%AF%B7%E6%B1%82"><span class="toc-number">14.</span> <span class="toc-text">对AJAX的理解，实现一个AJAX请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">ajax、axios、fetch的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">forEach和map方法有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">什么是尾调用，使用尾调用有什么好处？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">你用过哪些设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.</span> <span class="toc-text">如何实现深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.0.1.</span> <span class="toc-text">深拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">21.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">22.</span> <span class="toc-text">实现寄生组合继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%B7%B2%E7%BB%8F%E5%AE%83%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">23.</span> <span class="toc-text">对闭包的理解已经它的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%B8%80%E5%AE%9A%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-number">23.1.</span> <span class="toc-text">闭包一定会造成内存泄漏吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">24.</span> <span class="toc-text">对作用域、作用域链的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#call-%E3%80%81bind%EF%BC%88%EF%BC%89%E3%80%81-apply-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">call() 、bind（）、 apply() 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%A4%9A%E4%B8%AA-bind%EF%BC%8C%E6%9C%80%E5%90%8Ethis%E6%8C%87%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">25.0.1.</span> <span class="toc-text">连续多个 bind，最后this指向是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">26.</span> <span class="toc-text">浏览器的垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-number">26.0.1.</span> <span class="toc-text">新生代（副垃圾回收器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3%EF%BC%88%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-number">26.0.2.</span> <span class="toc-text">老生代（主垃圾回收器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">26.0.3.</span> <span class="toc-text">引用计数法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">26.1.</span> <span class="toc-text">哪些情况会导致内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-number">27.</span> <span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99instanceof"><span class="toc-number">27.1.</span> <span class="toc-text">手写instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">27.2.</span> <span class="toc-text">手写new操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">27.3.</span> <span class="toc-text">手写深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99call"><span class="toc-number">27.4.</span> <span class="toc-text">手写call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99apply"><span class="toc-number">27.5.</span> <span class="toc-text">手写apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99bind"><span class="toc-number">27.6.</span> <span class="toc-text">手写bind</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/code/" title="算法"><img src="https://img0.baidu.com/it/u=873097404,573333836&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=801&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/2025/03/19/code/" title="算法">算法</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/front-introduction/" title="前端入门"><img src="https://img2.baidu.com/it/u=3514067637,2951611904&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=875&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端入门"/></a><div class="content"><a class="title" href="/2025/03/19/front-introduction/" title="前端入门">前端入门</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/file-upload/" title="文件上传（批量+git）"><img src="https://img2.baidu.com/it/u=1752158855,1571382153&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=1400" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件上传（批量+git）"/></a><div class="content"><a class="title" href="/2025/03/18/file-upload/" title="文件上传（批量+git）">文件上传（批量+git）</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/first-eassay/" title="前端js八股"><img src="https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端js八股"/></a><div class="content"><a class="title" href="/2025/03/18/first-eassay/" title="前端js八股">前端js八股</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/hello-world/" title="Hello World"><img src="https://pic4.zhimg.com/v2-0d5dd12da572c59207694beca78e4baf_1440w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/03/17/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-16T16:00:00.000Z" title="发表于 2025-03-17 00:00:00">2025-03-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic1.zhimg.com/v2-2c8825cd6e3549ee67da137ea7259f7c_1440w.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By stefan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>